#novel_generator/common.py
# -*- coding: utf-8 -*-
"""é€šç”¨é‡è¯•ã€æ¸…æ´—ã€æ—¥å¿—å·¥å…·"""
import logging
import re
import time
import traceback
import threading
import queue
import sys
import sys

def call_with_retry(func, max_retries=3, sleep_time=2, fallback_return=None, **kwargs):
    """é€šç”¨çš„é‡è¯•æœºåˆ¶å°è£…ã€‚
    :param func: è¦æ‰§è¡Œçš„å‡½æ•°
    :param max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°
    :param sleep_time: é‡è¯•å‰çš„ç­‰å¾…ç§’æ•°
    :param fallback_return: å¦‚æœå¤šæ¬¡é‡è¯•ä»å¤±è´¥æ—¶çš„è¿”å›å€¼
    :param kwargs: ä¼ ç»™funcçš„å‘½åå‚æ•°
    :return: funcçš„ç»“æœï¼Œè‹¥å¤±è´¥åˆ™è¿”å› fallback_return
    """
    for attempt in range(1, max_retries + 1):
        try:
            return func(**kwargs)
        except Exception as e:
            logging.warning(f"[call_with_retry] Attempt {attempt} failed with error: {e}")
            traceback.print_exc()
            if attempt < max_retries:
                time.sleep(sleep_time)
            else:
                logging.error("Max retries reached, returning fallback_return.")
                return fallback_return

def remove_think_tags(text: str) -> str:
    """ç§»é™¤ <think>...</think> åŒ…è£¹çš„å†…å®¹"""
    return re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL)

def debug_log(prompt: str, response_content: str):
    logging.info(
        f"\n[#########################################  Prompt  #########################################]\n{prompt}\n"
    )
    logging.info(
        f"\n[######################################### Response #########################################]\n{response_content}\n"
    )

def stream_print(text: str, end: str = "", thinking: bool = False):
    """æµå¼æ‰“å°æ–‡æœ¬ï¼Œç›´æ¥æŒ‰ç…§LLMè¿”å›çš„tokené€Ÿåº¦æ˜¾ç¤º
    Args:
        text: è¦æ‰“å°çš„æ–‡æœ¬
        end: ç»“æŸå­—ç¬¦
        thinking: æ˜¯å¦æ˜¯æ€ç»´é“¾å†…å®¹
    """
    if not text:
        return
        
    prefix = "ğŸ’­ " if thinking else "ğŸ¤– "
    
    # ç¡®ä¿textæ˜¯å­—ç¬¦ä¸²ç±»å‹
    text_str = str(text)
    
    # ä»…åœ¨æ–°æ®µè½å¼€å§‹æ—¶æ·»åŠ å‰ç¼€
    if text_str.startswith('\n'):
        sys.__stdout__.write(prefix)
    
    # ç›´æ¥æ‰“å°æ–‡æœ¬ï¼Œè®©tokenè‡ªç„¶æµå‡º
    sys.__stdout__.write(text_str)
    sys.__stdout__.write(end)
    sys.__stdout__.flush()

def extract_thinking_content(response_chunk):
    """ä»ä¸åŒæ¨¡å‹çš„å“åº”ä¸­æå–æ€ç»´é“¾å†…å®¹
    Returns:
        tuple: (æ€ç»´é“¾å†…å®¹, æœ€ç»ˆå›ç­”)
    """
    thinking_content = None
    content = None
    
    # DeepSeekæ¨¡å‹
    if hasattr(response_chunk, 'choices') and response_chunk.choices and hasattr(response_chunk.choices[0].delta, 'reasoning_content'):
        thinking_content = response_chunk.choices[0].delta.reasoning_content
        content = response_chunk.choices[0].delta.content
        
    # Geminiæ¨¡å‹
    elif hasattr(response_chunk, 'parts') and response_chunk.parts:
        # Geminiçš„æ€ç»´é“¾åœ¨candidatesä¸­
        candidates = getattr(response_chunk, 'candidates', [])
        if candidates:
            thinking_content = str(candidates[0].content)
        content = str(getattr(response_chunk, 'text', ''))
        
    # OpenAIæ¨¡å‹
    elif hasattr(response_chunk, 'choices') and response_chunk.choices:
        content = response_chunk.choices[0].delta.content
        if content and '<think>' in content:
            thinking_match = re.search(r'<think>(.*?)</think>', content)
            if thinking_match:
                thinking_content = thinking_match.group(1)
                content = re.sub(r'<think>.*?</think>', '', content)
    
    return thinking_content, content

def invoke_with_cleaning(llm_adapter, prompt: str, max_retries: int = 3, check_interrupted=None, log_func=None) -> str:
    """ä½¿ç”¨æµå¼è¾“å‡ºè°ƒç”¨ LLM å¹¶æ¸…ç†è¿”å›ç»“æœ"""
    result_text = ""
    for chunk in invoke_stream_with_cleaning(llm_adapter, prompt, max_retries, check_interrupted, log_func):
        result_text += chunk
    return result_text

def invoke_stream_with_cleaning(llm_adapter, prompt: str, max_retries: int = 3, check_interrupted=None, log_func=None):
    """
    ä½¿ç”¨æµå¼è¾“å‡ºè°ƒç”¨ LLMï¼Œå¹¶ä»¥ç”Ÿæˆå™¨æ–¹å¼è¿”å›æ¸…ç†åçš„æ–‡æœ¬å—ã€‚
    å¢åŠ äº†åœ¨LLMæ€è€ƒæ—¶çš„è¯»ç§’è®¡æ—¶åŠŸèƒ½ï¼Œå¹¶èƒ½åœ¨GUIæ—¥å¿—ä¸­åæ˜ ã€‚
    """
    sys.__stdout__.write("\n" + "="*70 + "\n")
    sys.__stdout__.write("å‘é€åˆ° LLM çš„æç¤ºè¯:\n")
    sys.__stdout__.write("-"*70 + "\n")
    sys.__stdout__.write(prompt + "\n")
    sys.__stdout__.write("="*70 + "\n\n")
    sys.__stdout__.flush()

    retry_count = 0
    while retry_count < max_retries:
        stop_event = threading.Event()
        timer_thread = None
        
        final_elapsed_time = 0
        def _timer():
            nonlocal final_elapsed_time
            start_time = time.time()

            while not stop_event.is_set():
                elapsed = time.time() - start_time
                final_elapsed_time = elapsed
                
                message = f"LLM æ­£åœ¨æ€è€ƒ...  ï¼ˆ{elapsed:.1f} ç§’ï¼‰"
                
                # æ›´æ–°ç»ˆç«¯è®¡æ—¶å™¨
                sys.__stdout__.write(f"\r{message}")
                sys.__stdout__.flush()
                
                # æ›´æ–°GUIæ—¥å¿—
                if log_func:
                    # å¯¹äºè®¡æ—¶å™¨ï¼Œæ€»æ˜¯æ›¿æ¢æœ€åä¸€è¡Œ
                    log_func(message, replace_last_line=True)
                
                time.sleep(0.1)
            
            # è®¡æ—¶ç»“æŸï¼Œåœ¨ç»ˆç«¯å’ŒGUIæ‰“å°æœ€ç»ˆè€—æ—¶
            final_message = f"LLM æ€è€ƒå®Œæ¯•ï¼Œå…±è€—æ—¶ {final_elapsed_time:.2f} ç§’"
            sys.__stdout__.write(f"\r{final_message}\n")
            sys.__stdout__.flush()
            if log_func:
                log_func(final_message, replace_last_line=True)

        try:
            if check_interrupted and check_interrupted():
                yield "ä»»åŠ¡å·²ä¸­æ–­"
                return

            # å¯åŠ¨è®¡æ—¶å™¨
            timer_thread = threading.Thread(target=_timer)
            timer_thread.daemon = True
            timer_thread.start()

            stream = llm_adapter.invoke_stream(prompt)
            if not stream:
                raise Exception("Failed to get stream response")

            first_chunk = True
            for chunk in stream:
                if first_chunk:
                    # æ”¶åˆ°ç¬¬ä¸€ä¸ªæ•°æ®å—ï¼Œåœæ­¢è®¡æ—¶å™¨
                    stop_event.set()
                    timer_thread.join()
                    sys.__stdout__.write("\n" + "="*70 + "\n")
                    sys.__stdout__.write("LLMè¿”å›å†…å®¹:\n")
                    sys.__stdout__.write("-"*70 + "\n")
                    sys.__stdout__.flush()
                    first_chunk = False

                if check_interrupted and check_interrupted():
                    yield "ä»»åŠ¡å·²ä¸­æ–­"
                    return
                
                content = chunk
                
                if content:
                    sys.__stdout__.write(content)
                    sys.__stdout__.flush()
                    
                    # å°†æµå¼å†…å®¹ä¹Ÿè¾“å‡ºåˆ°GUIæ—¥å¿—
                    # if log_func:
                    #     log_func(content, stream=True)
                        
                    cleaned_content = content.replace("```", "")
                    yield cleaned_content
            
            if not first_chunk: # ç¡®ä¿å³ä½¿æµä¸ºç©ºä¹Ÿæ‰“å°ç»“æŸç¬¦
                sys.__stdout__.write("\n" + "="*70 + "\n")
                sys.__stdout__.flush()
            
            return

        except Exception as e:
            error_message = f"è°ƒç”¨å¤±è´¥ ({retry_count + 1}/{max_retries}): {str(e)}"
            sys.__stdout__.write(f"\né”™è¯¯: {error_message}\n")
            sys.__stdout__.flush()
            logging.error(error_message)
            
            retry_count += 1
            if retry_count >= max_retries:
                final_error = f"\né”™è¯¯ï¼šLLMè°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°: {e}"
                sys.__stdout__.write(final_error + "\n")
                sys.__stdout__.flush()
                yield final_error
                return
            time.sleep(2)
        finally:
            # ç¡®ä¿è®¡æ—¶å™¨çº¿ç¨‹åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½èƒ½åœæ­¢
            if timer_thread and timer_thread.is_alive():
                stop_event.set()
                timer_thread.join()

def invoke_llm(llm_adapter, prompt: str, max_retries: int = 3, log_func=None) -> str:
    """ç›´æ¥è°ƒç”¨ LLM å¹¶è¿”å›ç»“æœï¼ŒåŒ…å«é‡è¯•æœºåˆ¶ã€‚"""
    # å¤ç”¨ invoke_with_cleaning çš„é€»è¾‘
    return invoke_with_cleaning(llm_adapter, prompt, max_retries, log_func=log_func)

# æ·»åŠ å¼‚æ­¥ç‰ˆæœ¬çš„LLMè°ƒç”¨å‡½æ•°
class AsyncLLMInvoker:
    """å¼‚æ­¥LLMè°ƒç”¨å™¨ï¼Œä½¿ç”¨çº¿ç¨‹æ± å’Œå›è°ƒæœºåˆ¶å®ç°éé˜»å¡è°ƒç”¨"""
    
    def __init__(self, max_workers=5):
        """åˆå§‹åŒ–å¼‚æ­¥è°ƒç”¨å™¨
        
        Args:
            max_workers: æœ€å¤§å·¥ä½œçº¿ç¨‹æ•°
        """
        self.result_queues = {}
        self.max_workers = max_workers
        self.workers = []
        self.task_queue = queue.Queue()
        self._start_workers()
    
    def _start_workers(self):
        """å¯åŠ¨å·¥ä½œçº¿ç¨‹"""
        for _ in range(self.max_workers):
            worker = threading.Thread(target=self._worker_loop, daemon=True)
            worker.start()
            self.workers.append(worker)
    
    def _worker_loop(self):
        """å·¥ä½œçº¿ç¨‹å¾ªç¯ï¼Œä»ä»»åŠ¡é˜Ÿåˆ—è·å–ä»»åŠ¡å¹¶æ‰§è¡Œ"""
        while True:
            try:
                task_id, llm_adapter, prompt, max_retries, callback = self.task_queue.get()
                try:
                    # è°ƒç”¨åŒæ­¥ç‰ˆæœ¬çš„invoke_llmå‡½æ•°
                    result = invoke_llm(llm_adapter, prompt, max_retries)
                    # å¦‚æœæä¾›äº†å›è°ƒå‡½æ•°ï¼Œåˆ™è°ƒç”¨å›è°ƒ
                    if callback:
                        callback(result)
                except Exception as e:
                    logging.error(f"Error in worker thread: {str(e)}")
                    if callback:
                        callback(None, str(e))
                finally:
                    self.task_queue.task_done()
            except Exception as e:
                logging.error(f"Worker loop error: {str(e)}")
    
    def invoke_async(self, llm_adapter, prompt, callback=None, max_retries=3):
        """å¼‚æ­¥è°ƒç”¨LLM
        
        Args:
            llm_adapter: LLMé€‚é…å™¨
            prompt: æç¤ºè¯
            callback: å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶ç»“æœå’Œå¯é€‰çš„é”™è¯¯ä¿¡æ¯
            max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°
        """
        task_id = id(prompt)
        self.task_queue.put((task_id, llm_adapter, prompt, max_retries, callback))
        return task_id

# åˆ›å»ºå…¨å±€å¼‚æ­¥è°ƒç”¨å™¨å®ä¾‹
async_invoker = AsyncLLMInvoker()

def invoke_llm_async(llm_adapter, prompt, callback=None, max_retries=3):
    """å¼‚æ­¥è°ƒç”¨LLMçš„ä¾¿æ·å‡½æ•°
    
    Args:
        llm_adapter: LLMé€‚é…å™¨
        prompt: æç¤ºè¯
        callback: å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶ç»“æœå’Œå¯é€‰çš„é”™è¯¯ä¿¡æ¯
        max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°
    """
    return async_invoker.invoke_async(llm_adapter, prompt, callback, max_retries)

def invoke_with_cleaning_async(llm_adapter, prompt, callback=None, max_retries=3):
    """å¼‚æ­¥è°ƒç”¨LLMå¹¶æ¸…ç†ç»“æœçš„ä¾¿æ·å‡½æ•°
    
    Args:
        llm_adapter: LLMé€‚é…å™¨
        prompt: æç¤ºè¯
        callback: å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶æ¸…ç†åçš„ç»“æœå’Œå¯é€‰çš„é”™è¯¯ä¿¡æ¯
        max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°
    """
    def clean_and_callback(result, error=None):
        if error:
            if callback:
                callback(None, error)
            return
        
        # æ¸…ç†ç»“æœ
        cleaned_result = result.replace("```", "").strip() if result else ""
        if callback:
            callback(cleaned_result)
    
    return async_invoker.invoke_async(llm_adapter, prompt, clean_and_callback, max_retries)

# æ·»åŠ å¼‚æ­¥ç‰ˆæœ¬çš„update_character_stateså‡½æ•°
def update_character_states_async(chapter_text, chapter_title, chap_num, filepath, llm_adapter, embedding_adapter, chapter_blueprint_content="", callback=None, log_func=None):
    """å¼‚æ­¥ç‰ˆæœ¬çš„è§’è‰²çŠ¶æ€æ›´æ–°å‡½æ•°
    
    Args:
        chapter_text: ç« èŠ‚æ–‡æœ¬
        chapter_title: ç« èŠ‚æ ‡é¢˜
        chap_num: ç« èŠ‚ç¼–å·
        filepath: æ–‡ä»¶ä¿å­˜è·¯å¾„
        llm_adapter: LLMé€‚é…å™¨
        embedding_adapter: åµŒå…¥é€‚é…å™¨
        chapter_blueprint_content: ç« èŠ‚ç›®å½•å†…å®¹
        callback: å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶æ›´æ–°ç»“æœå’Œå¯é€‰çš„é”™è¯¯ä¿¡æ¯
        log_func: æ—¥å¿—è®°å½•å‡½æ•°
    """
    def task():
        try:
            from novel_generator.character_state_updater import update_character_states
            result = update_character_states(chapter_text, chapter_title, chap_num, filepath, llm_adapter, embedding_adapter, chapter_blueprint_content, log_func=log_func)
            if callback:
                callback(result)
        except Exception as e:
            logging.error(f"Error in update_character_states_async: {str(e)}")
            if callback:
                callback({"status": "error", "message": str(e), "character_state": ""})
    
    thread = threading.Thread(target=task)
    thread.daemon = True
    thread.start()
    return thread

def execute_with_polling(gui_app, step_name: str, target_func, *args, **kwargs):
    """
    æ‰§è¡Œä¸€ä¸ªç›®æ ‡å‡½æ•°ï¼Œå¹¶åœ¨LLMè°ƒç”¨å¤±è´¥æ—¶ä½¿ç”¨è½®è¯¢ç®¡ç†å™¨è¿›è¡Œé‡è¯•ã€‚
    è¿™æ˜¯å®ç°æ¨¡å‹è‡ªåŠ¨åˆ‡æ¢çš„æ ¸å¿ƒé€»è¾‘ã€‚

    :param gui_app: ä¸»GUIåº”ç”¨çš„å®ä¾‹ï¼Œç”¨äºæ—¥å¿—è®°å½•ã€‚
    :param step_name: å½“å‰æ‰§è¡Œçš„æ­¥éª¤åç§° (ä¾‹å¦‚, 'ç”Ÿæˆåˆç¨¿', 'é‡å†™')ã€‚
    :param target_func: è¦æ‰§è¡Œçš„ç›®æ ‡å‡½æ•° (ä¾‹å¦‚, generate_chapter_draft_logic)ã€‚
    :param args: ä¼ é€’ç»™ç›®æ ‡å‡½æ•°çš„ä½ç½®å‚æ•°ã€‚
    :param kwargs: ä¼ é€’ç»™ç›®æ ‡å‡½æ•°çš„å…³é”®å­—å‚æ•°ã€‚
    :return: ç›®æ ‡å‡½æ•°çš„è¿”å›å€¼ï¼Œå¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥åˆ™è¿”å›Noneã€‚
    """
    from llm_adapters import PollingManager
    polling_manager = PollingManager()
    
    # ç¡®å®šè¦ä½¿ç”¨çš„é…ç½®åˆ—è¡¨
    step_config = polling_manager.step_configs.get(step_name, {})
    specific_config_name = step_config.get("æŒ‡å®šé…ç½®")
    if specific_config_name and specific_config_name != "æ— ":
        effective_list = [{"name": specific_config_name}]
    else:
        effective_list = polling_manager.polling_list

    if not effective_list:
        gui_app.safe_log(f"é”™è¯¯ï¼šæ­¥éª¤ '{step_name}' æ²¡æœ‰ä»»ä½•å¯ç”¨çš„LLMé…ç½®ã€‚")
        return None

    max_attempts = len(effective_list)

    for attempt in range(max_attempts):
        # åœ¨æ¯æ¬¡å¾ªç¯å¼€å§‹æ—¶é‡ç½®éšæœºç´¢å¼•ï¼Œä»¥ç¡®ä¿éšæœºç­–ç•¥åœ¨é‡è¯•æ—¶ä¹Ÿèƒ½æ­£ç¡®å·¥ä½œ
        if hasattr(polling_manager, '_random_indices'):
            delattr(polling_manager, '_random_indices')

        llm_adapter, config_name = polling_manager.get_adapter_for_step(step_name, attempt=attempt)

        if not llm_adapter:
            gui_app.safe_log(f"è­¦å‘Šï¼šæ— æ³•ä¸ºæ­¥éª¤ '{step_name}' è·å–é…ç½® '{config_name}'ã€‚")
            continue

        gui_app.safe_log(f"æ­¥éª¤ '{step_name}' æ­£åœ¨å°è¯•ä½¿ç”¨é…ç½® '{config_name}' (å°è¯• {attempt + 1}/{max_attempts})...")
        
        try:
            # å°†llm_adapteræ³¨å…¥åˆ°kwargsä¸­ï¼Œä¾›ç›®æ ‡å‡½æ•°ä½¿ç”¨
            kwargs['llm_adapter'] = llm_adapter
            result = target_func(*args, **kwargs)
            
            # å‡è®¾å¦‚æœå‡½æ•°æˆåŠŸæ‰§è¡Œä½†è¿”å›Noneæˆ–ç©ºå­—ç¬¦ä¸²ï¼Œä¹Ÿè§†ä¸ºä¸€ç§â€œè½¯å¤±è´¥â€
            # ä½†è¿™é‡Œæˆ‘ä»¬ä¿¡ä»»ç›®æ ‡å‡½æ•°è‡ªå·±çš„åˆ¤æ–­ï¼Œåªè¦ä¸æŠ›å¼‚å¸¸å°±ç®—æˆåŠŸ
            gui_app.safe_log(f"âœ… æ­¥éª¤ '{step_name}' ä½¿ç”¨é…ç½® '{config_name}' æˆåŠŸã€‚")
            return result
        
        except InterruptedError:
            gui_app.safe_log(f"ğŸŸ¡ ä»»åŠ¡è¢«ç”¨æˆ·ä¸­æ–­ã€‚")
            # ç”¨æˆ·ä¸­æ–­åº”è¯¥ç«‹å³åœæ­¢æ•´ä¸ªå·¥ä½œæµ
            raise
        except Exception as e:
            error_msg = f"âŒ é…ç½® '{config_name}' åœ¨æ­¥éª¤ '{step_name}' ä¸­å¤±è´¥: {str(e)}"
            gui_app.safe_log(error_msg)
            traceback.print_exc() # æ‰“å°è¯¦ç»†çš„tracebackåˆ°æ§åˆ¶å°/æ—¥å¿—æ–‡ä»¶
            
            # å¦‚æœè¿™æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œåˆ™è®°å½•æœ€ç»ˆçš„å¤±è´¥ä¿¡æ¯
            if attempt == max_attempts - 1:
                gui_app.safe_log(f"âŒ é”™è¯¯ï¼šæ­¥éª¤ '{step_name}' å·²å°è¯•æ‰€æœ‰å¯ç”¨é…ç½®ï¼Œä½†å‡å¤±è´¥ã€‚")
                return None # æˆ–è€…å¯ä»¥æŠ›å‡ºæœ€ç»ˆçš„å¼‚å¸¸
    
    return None # æ‰€æœ‰å°è¯•éƒ½å¤±è´¥äº†

import os
from utils import read_file

def get_chapter_filepath(filepath: str, chapter_num: int) -> str:
    """
    æ ¹æ®ç« èŠ‚å·ç”Ÿæˆæ ‡å‡†çš„æ–‡ä»¶è·¯å¾„ï¼Œæ–‡ä»¶åæ ¼å¼ä¸º "ç¬¬Xç«  ç« èŠ‚å.txt"ã€‚
    ç« èŠ‚åä» ç« èŠ‚ç›®å½•.txt ä¸­æå–ã€‚

    :param filepath: é¡¹ç›®æ ¹ç›®å½•çš„è·¯å¾„ã€‚
    :param chapter_num: ç« èŠ‚å·ã€‚
    :return: æ ‡å‡†åŒ–çš„ç« èŠ‚æ–‡ä»¶å®Œæ•´è·¯å¾„ã€‚
    """
    directory_file = os.path.join(filepath, "ç« èŠ‚ç›®å½•.txt")
    chapter_title = f"æ— æ ‡é¢˜ç« èŠ‚"  # é»˜è®¤æ ‡é¢˜

    if os.path.exists(directory_file):
        directory_content = read_file(directory_file)
        # å¢å¼ºçš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¯ä»¥åŒ¹é… "ç¬¬Xç«  ã€Šç« èŠ‚åã€‹" æˆ– "ç¬¬Xç«  ç« èŠ‚å"
        match = re.search(rf"^ç¬¬\s*{chapter_num}\s*ç« \s*(?:ã€Š([^ã€‹]+)ã€‹|([^\n]+))", directory_content, re.MULTILINE)
        if match:
            # match.group(1) å¯¹åº”ã€Šç« èŠ‚åã€‹ï¼Œmatch.group(2) å¯¹åº” "ç« èŠ‚å"
            title_candidate = match.group(1) or match.group(2)
            if title_candidate:
                chapter_title = title_candidate.strip()

    # ç§»é™¤Windowsæ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
    safe_title = re.sub(r'[\\/*?:"<>|]', '', chapter_title)
    
    # æ–°çš„æ–‡ä»¶åæ ¼å¼
    filename = f"ç¬¬{chapter_num}ç«  {safe_title}.txt"
    
    # æ–°çš„æ–‡ä»¶å¤¹åç§°
    chapter_folder = os.path.join(filepath, "ç« èŠ‚æ­£æ–‡")
    
    # ç¡®ä¿æ–‡ä»¶å¤¹å­˜åœ¨
    os.makedirs(chapter_folder, exist_ok=True)
    
    return os.path.join(chapter_folder, filename)
